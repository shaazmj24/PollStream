from flask import Flask, render_template, request, redirect, url_for
from flask_socketio import SocketIO 
from flask import abort 
import random 
import string 
import json 
import time

app = Flask(__name__)
polls = {} 

@app.route('/')
def home():   
    return render_template('home.html') 

def generate_code(): 
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=4))  #k=n returns list of random elements, join combine list into one string. 
                                                                                 #the '' represents something between letter. for e.g '-' then A-1-B-B-3

@app.route('/create', methods=['POST', 'GET']) 
def create(): 
    if request.method == 'POST': 
        time = request.form.get('time')
        question = request.form.get('ques') 
        options = [request.form.get(letter) for letter in string.ascii_uppercase if request.form.get(letter)]   #if op returns actual value otherwie none  
        poll_code = generate_code()
        while poll_code in polls: 
            poll_code = generate_code()
        
        polls[poll_code] = { 
            "ques": question, 
            "time": time, 
            "options": options, 
        }  
        return render_template('code.html', poll_code=poll_code)
    return render_template('create.html') 
 
@app.route('/join', methods=['GET', 'POST'])
def join(): 
    if request.method == 'POST': 
        code_entered = request.form.get('code').upper().strip()
        if code_entered in polls: 
            return redirect(url_for('view_poll', code=code_entered))
        else: 
            return abort(404) 
    
    return render_template('join.html') 

@app.route('/poll/<code>')
def view_poll(code): 
    return render_template('poll.html', code=polls[code], timer=polls[code]["time"])  

@app.route('/result', methods=['POST']) 
def chart():  
    option_hashmap = {}
    option = request.form.get('v')
    if (option == "none"):  
        choice, selected = None, None
    else:  
        choice, selected = option.split("&")
        if choice in option_hashmap: 
            option_hashmap(choice) += 1
        else:  
            option_hashmap(choice) = 1
    
    letter = list(option_hashmap.keys())
    times = list(option_hashmap.values())

    return render_template('chart.html', selected=selected, choice=choice, letter=letter, times=times)


if __name__ == '__main__':  
    app.run(debug=True)   







chart file: 



<!DOCTYPE html>
<html>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js"></script>
<body>

<canvas id="myChart" style="width:500%;max-width:2000px"></canvas>

<script>
var xValues = ["A", "B", "C", "D", "E"];
var yValues = [55, 50, 24, 90, 30];
var barColors = ["cyan", "cyan","cyan","cyan","cyan"];

new Chart("myChart", {
  type: "bar",
  data: {
    labels: xValues,
    datasets: [{
      backgroundColor: barColors,
      data: yValues
    }]
  },
  options: {
    legend: {display: false},
    title: {
      display: true,
      text: "Vote"
    }
  }
});
</script>

</body>
</html>





voters will use the same link (admin), same flask server. 

disploy app




<h1 id="h">  
            <span>Poll</span>
            <span>Stream</span>
        </h1>
        <div id="buttons"> 
            <button onclick="location.href='/create'">Create Poll</button>
            <button onclick="location.href='/join'">Join Poll</button>
        </div>


{% for option in code["options"] %}  
            <input type="radio" value="{{loop.index0}}" name="vote">  
            {{ option }} <br> 
            {% endfor %}



button { 
    position: relative; 
    background-color: black;
    color: white; 
    border: none;
    padding: 10px 15px;
    font-size: 16px;
    border-radius: 6px;
    cursor: pointer;
    top: 54px; 
  }


{% for option in code["options"] %}  
            <label id="cl" class="option"> 
                <input type="radio" value="{{loop.index0}}" name="vote"> 
                <span class="circle">A</span> {{ option }} 
            </label>  
            {% endfor %} 


@app.route('/chart', method=['POST', 'GET'])
def chart(): 
    return "stub"



<!DOCTYPE html>
<html lang="en">  
    <head>
        <title>Chart</title>
    </head>
    <body> 
        <script>scr="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"</script>
        <canvas id="myChart" style="width:100%;max-width:700px"></canvas>
        <script>   
            const myChart = new Chart("myChart", { 
                type: "bar", 
                data: {}, 
                options: {} 
            });
        </script>
        <h1> 
            {{ selected }}
            {{choice}}
        </h1>
    </body>
</html>























<!DOCTYPE html> 
<html lang="eng"> 
    <head> 
        <title>Poll Time</title>
    </head> 
    <style>   
    
    body { 
        font-family: Arial, sans-serif; 
        display: flex; 
        justify-content: center; 
        padding: 40px; 
        background-color: lightblue; 
    } 
    
    form { 
        position: relative;  
        background-color: white; 
        padding: 25px 30px; 
        box-shadow: 0 4px 12px rgba(0,0,0,0.1); 
        width: 1500px;  
        height: 600px; 
        top: 40px; 
    } 
    
    button:hover {   
        background-color: lightblue; 
        color: black;  
    } 
    
    input[type="radio"] {     
        transform: scale(3.1); 
    }

    input[type="radio"]:checked + .circle {
      background-color: lightblue;
      color: black;
      border-color: lightblue;
    }

    .option {
      display: flex;
      align-items: center;
      margin-bottom: 22px;
      cursor: pointer;
    }

    .circle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid #333;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      margin-right: 12px;
      transition: all 0.2s ease;
    } 

    input[type="radio"] {
      display: none;
    }

    #timer {   
        position: absolute;  
        right: 20px;
        top: 30px;
        font-size: 20px;
    }

    #Tim { 
        position: absolute;  
        right: 49px;
        font-size: 25px;
    } 

    #rs { 
        position: relative; 
        background-color: black; 
        color: white; 
        border: none; 
        padding: 10px 15px; 
        font-size: 16px; 
        border-radius: 6px; 
        cursor: pointer;
        float: right;      
    }

    #ques { 
        position: relative; 
        font-size: 40px;     
        font-weight: bold;
    }

    </style>
    <body>   
        <form id="myform">   
            <span id="Tim">Timer: </span>
            <span id="timer">{{ code["time"] }}</span>
            <p id="ques">{{ code["ques"] }}</p>   
            {% for option in code["options"] %}  
            <label class="option">    
                <input type="radio" name="vote" value="{{option}}&{{ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[loop.index0] }}"> 
                <span class="circle"></span>
                {{ option }} 
            </label>  
            {% endfor %} 
        </form>
        <script>  
            const circles = document.querySelectorAll('.circle'); 
            circles.forEach((circle, index) => { 
                const letter = String.fromCharCode(65 + index);
                circle.textContent = letter; 
            });
        </script>
        <script> 
            let timeCounter = parseInt(document.getElementById("timer").textContent);   

            const interval = setInterval(function() {   // interval varaibe only if you want to stop countdown so clearInterval(variable)
                document.getElementById("timer").textContent = timeCounter; 
                timeCounter--; 

                if (timeCounter < 0) {  
                    clearInterval(interval)
                    document.getElementById("Tim").textContent = "Time's up:"  

                    //get selected radio value
                    const selected = document.querySelector('input[name="vote"]:checked'); 
                    const selectedValue = selected ? selected.value : "none"; 

                    //create hidden input to preserve the value and allow post action or submission (always input)
                    const hiddeninput = document.createElement("input");  
                    hiddeninput.type = "hidden"; 
                    hiddeninput.name = "v"; 
                    hiddeninput.value = selectedValue; 
                    document.querySelector("form").appendChild(hiddeninput);  

                    const rs = document.createElement("div");  
                    rs.innerHTML = `<button id="rs" type="button">Show Result</button>`   
                    document.querySelector("form").appendChild(rs); 

                    document.getElementById("rs").addEventListener("click", function() { 
                        window.location.href = "/chart"; 
                    }); 

                    // disbale all radio buttons
                    const radios = document.querySelectorAll('input[type="radio"]'); 
                    radios.forEach(radio => radio.disabled = true); 

                    // auto submit the form 
                    document.getElementById("myform").submit();  //old code
                }
            }, 1000)
        </script>
    </body>
</html>
















@socketio.on("join_room")
def f2(data):  

@socketio.on("vote_casted") 
def (data):  














from flask import Flask, render_template, request, redirect, url_for, session
from flask_socketio import SocketIO 
from flask import abort 
from flask_socketio import emit, join_room, leave_room
import random 
import string 
import json 
import time

app = Flask(__name__)
app.secret_key = '8989dog4040'
polls = {} 
socketio = SocketIO(app)       # Creates an instance. Wraps your Flask app with Socket.IO functionality. Enables real-time, bi-directional 
                               # communication between clients (browser) and your Flask server over WebSockets

@app.route('/')
def home():   
    return render_template('home.html') 

def generate_code(): 
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=4))  #k=n returns list of random elements, join combine list into one string. 
                                                                                 #the '' represents something between letter. for e.g '-' then A-1-B-B-3

@app.route('/create', methods=['POST', 'GET']) 
def create(): 
    if request.method == 'POST': 
        time = request.form.get('time')
        question = request.form.get('ques') 
        options = [request.form.get(letter) for letter in string.ascii_uppercase if request.form.get(letter)]   #if op returns actual value otherwie none  
        poll_code = generate_code()
        while poll_code in polls: 
            poll_code = generate_code()
        
        polls[poll_code] = { 
            "ques": question, 
            "time": time, 
            "options": options, 
        }  
        return render_template('code.html', poll_code=poll_code)
    return render_template('create.html') 
 
@app.route('/join', methods=['GET', 'POST'])
def join(): 
    if request.method == 'POST': 
        code_entered = request.form.get('code').upper().strip()
        if code_entered in polls: 
            return redirect(url_for('view_poll', code=code_entered))
        else: 
            return abort(404) 
    
    return render_template('join.html') 

@app.route('/poll/<code>')
def view_poll(code): 
    return render_template('poll.html', code=polls[code], timer=polls[code]["time"], identity=code)  


@app.route('/result', methods=['POST'])
def voters():  
    identity = request.form.get('identity')
    option = request.form.get('vote')
    #make new session if not created yet (global variable)
    if identity in session: 
        choice_map = session[identity]
    else:   
        choice_map = {}

    if (option == "none"):  
        choice, selected = None, None
    else:  
        selected, choice = option.split("&")  
        if choice in choice_map:  
            choice_map[choice] += 1
        else: 
            choice_map[choice] = 1 

    #save updated map back to session 
    session[identity] = choice_map      #like session[#code#, variable]  
    return '', 204                          #return silent/empty response with 204 to avoid invalid response 
                                            #error and stay on the same page(poll). ideal for using AJAX JS

@app.route('/chart') 
def chart(): 
    identity = request.args.get("id")        #query parameter in url so use args 
    choice_map = session[identity] 
    key_choices = list(choice_map.keys())
    nofchoices = list(choice_map.values())

    return render_template('chart.html', key_choices=key_choices, nofchoices=nofchoices)

@app.route('/livechart', methods=['GET', 'POST'])
def livechart(): 
    identity = request.args.get("id") 
    choice_map = session[identity]
    key_choices = list(choice_map.keys())
    nofchoices = list(choice_map.values()) 
    
    return render_template('live.html', identity=identity, key_choices=key_choices, nofchoices=nofchoices)
    
@socketio.on("join_room")
def on_join(data):  
    room = data["id"]
    join_room(room)
    print(f"Admin joined room: {room}")      #creating private room. servers enter uniqe room will recieve and send data otherwise send to all connected socket clients

@socketio.on("vote_casted") 
def on_vote(data):   
    return ''

if __name__ == '__main__':  
    socketio.run(app, host='0.0.0.0', port=5001, debug=True)    #instead of app.run() cuz only supports hhtp not websocket.socketio supports both



